<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Canvas Pressure Brush (fixed coords + big size)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<style>
  :root { color-scheme: light dark; }
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#f5f5f5;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  #stage { position:fixed; inset:0; width:100vw; height:100vh; display:block; touch-action:none; background:#f5f5f5; }
  .toolbar { position:fixed; left:0; right:0; bottom:0; display:flex; gap:16px; align-items:center;
    padding:8px 12px; background:rgba(0,0,0,0.75); color:#fff; z-index:10; backdrop-filter:blur(4px); font-size:12px; }
  .toolbar label { display:flex; align-items:center; gap:6px; white-space:nowrap; }
  .toolbar input[type="range"] { width:220px; }
  .spacer { flex:1; }
</style>
</head>
<body>

<canvas id="stage"></canvas>

<div class="toolbar">
  <label>Spacing
    <input id="spacing" type="range" min="0.5" max="30" step="0.1" value="3">
    <span id="spacingVal">3.0 px</span>
  </label>
  <label>Size
    <input id="size" type="range" min="4" max="1000" step="1" value="36">
    <span id="sizeVal">36 px</span>
  </label>
  <label><input id="rotate" type="checkbox" checked> Align to stroke</label>
  <div class="spacer"></div>
  <span>Z = undo, C = clear</span>
</div>

<script>
// ---------- DPR-aware fullscreen canvas ----------
const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d', { alpha:false });

let dpr = 1, cssW = 0, cssH = 0;
function resizeCanvas() {
  dpr = Math.max(1, window.devicePixelRatio || 1);
  cssW = window.innerWidth;
  cssH = window.innerHeight;
  // Backing store in device pixels
  canvas.width  = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
  canvas.style.width  = cssW + 'px';
  canvas.style.height = cssH + 'px';
  // Draw in CSS-pixel coordinates
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  redraw();
}
window.addEventListener('resize', resizeCanvas);

// ---------- UI state ----------
let spacing = 3;
let brushSize = 36;
let rotateAlong = true;

const spacingInput = document.getElementById('spacing');
const sizeInput    = document.getElementById('size');
const rotateInput  = document.getElementById('rotate');
const spacingVal   = document.getElementById('spacingVal');
const sizeVal      = document.getElementById('sizeVal');

spacingInput.addEventListener('input', () => {
  spacing = parseFloat(spacingInput.value);
  spacingVal.textContent = `${spacing.toFixed(1)} px`;
  redraw();
});
sizeInput.addEventListener('input', () => {
  brushSize = parseInt(sizeInput.value, 10);
  sizeVal.textContent = `${brushSize} px`;
  redraw();
});
rotateInput.addEventListener('change', () => {
  rotateAlong = rotateInput.checked;
  redraw();
});

// ---------- Data model ----------
let paths = [];               // Array<Array<{x,y,p}>>
let currentPath = null;

// ---------- Brush images ----------
const brushImgs = [];
const TOTAL_BRUSHES = 12; // brush0.png .. brush5.png

function loadImage(src) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.decoding = 'async';
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}
async function preloadBrushes() {
  const jobs = [];
  for (let i = 1; i < TOTAL_BRUSHES; i++) jobs.push(loadImage(`slice${i}.png`));
  const images = await Promise.all(jobs);
  brushImgs.splice(0, brushImgs.length, ...images);
}

// ---------- Pointer handling (pressure + coalesced events) ----------
let isDrawing = false;
canvas.addEventListener('pointerdown', (e) => {
  const pt = getPointerXY(e);
  if (!inside(pt.x, pt.y)) return;
  canvas.setPointerCapture(e.pointerId);
  isDrawing = true;
  const p = clamp01(e.pressure ?? 0.5);
  currentPath = [{ x: pt.x, y: pt.y, p }];
  paths.push(currentPath);
  e.preventDefault();
  drawLastSegment(); // immediate feedback on first stamp
}, { passive:false });

canvas.addEventListener('pointermove', (e) => {
  if (!isDrawing || !currentPath) return;
  const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];
  for (const ev of events) {
    const pt = getPointerXY(ev);
    if (!inside(pt.x, pt.y)) continue;
    const p = clamp01(ev.pressure ?? 0.5);
    addInterpolatedPoint(currentPath, pt.x, pt.y, p, spacing);
  }
  e.preventDefault();
  drawLastSegment();
}, { passive:false });

canvas.addEventListener('pointerup', (e) => {
  if (canvas.hasPointerCapture(e.pointerId)) canvas.releasePointerCapture(e.pointerId);
  isDrawing = false;
  currentPath = null;
  e.preventDefault();
}, { passive:false });

canvas.addEventListener('pointercancel', (e) => {
  if (canvas.hasPointerCapture(e.pointerId)) canvas.releasePointerCapture(e.pointerId);
  isDrawing = false;
  currentPath = null;
  e.preventDefault();
}, { passive:false });

// Robust CSS-pixel coordinates (no DPR math needed here)
function getPointerXY(ev) {
  // Prefer offsetX/Y when the target is the canvas (already relative & in CSS px)
  if ('offsetX' in ev && ev.target === canvas) {
    return { x: ev.offsetX, y: ev.offsetY };
  }
  // Fallback to bounding rect
  const r = canvas.getBoundingClientRect();
  return { x: ev.clientX - r.left, y: ev.clientY - r.top };
}

function inside(x,y){ return x>=0 && x<cssW && y>=0 && y<cssH; }
function clamp01(v){ return v < 0 ? 0 : v > 1 ? 1 : v; }

// ---------- Resampling with pressure lerp ----------
function addInterpolatedPoint(path, x, y, p, sp) {
  const last = path[path.length - 1];
  const dx = x - last.x, dy = y - last.y;
  const d  = Math.hypot(dx, dy);
  if (d < sp) { path.push({ x, y, p }); return; }
  const steps = Math.floor(d / sp);
  for (let i = 1; i <= steps; i++) {
    const t = (i * sp) / d;
    path.push({ x: last.x + dx*t, y: last.y + dy*t, p: last.p + (p - last.p)*t });
  }
  path.push({ x, y, p });
}

// ---------- Rendering ----------
function redraw() {
  // Clear using CSS-pixel logical size
  ctx.fillStyle = '#f5f5f5';
  ctx.fillRect(0, 0, cssW, cssH);
  // Draw all paths
  for (const path of paths) drawPath(path);
}

function drawLastSegment() {
  if (!paths.length) return;
  const path = paths[paths.length - 1];
  // Just draw the last handful for responsiveness
  const start = Math.max(0, path.length - 16);
  for (let i = start; i < path.length; i++) drawStamp(path, i);
}

function drawPath(path) {
  for (let i = 0; i < path.length; i++) drawStamp(path, i);
}

function drawStamp(path, i) {
  const pt = path[i];
  const prev = i > 0 ? path[i - 1] : null;

  const n = brushImgs.length;
  if (!n) return;

  // Pressure â†’ brush index (equal bins)
  const idx = Math.min(Math.floor(pt.p * n), n - 1);
  const img = brushImgs[idx];

  // Scale: preserve aspect, longest side == brushSize
  const iw = img.naturalWidth || img.width;
  const ih = img.naturalHeight || img.height;
  const s  = brushSize / Math.max(iw, ih);
  const w  = iw * s, h = ih * s;

  let ang = 0;
  if (rotateAlong && prev) ang = Math.atan2(pt.y - prev.y, pt.x - prev.x);

  ctx.save();
  ctx.translate(pt.x, pt.y);
  if (ang) ctx.rotate(ang);
  ctx.drawImage(img, -w/2, -h/2, w, h);
  ctx.restore();
}

// ---------- Keyboard: undo / clear ----------
window.addEventListener('keydown', (e) => {
  if (e.key === 'z' || e.key === 'Z') {
    if (paths.length) paths.pop();
    currentPath = null;
    redraw();
  } else if (e.key === 'c' || e.key === 'C') {
    paths = [];
    currentPath = null;
    redraw();
  }
});

// ---------- Init ----------
(async function init(){
  await preloadBrushes();
  resizeCanvas();
  // init labels
  spacingVal.textContent = `${spacing.toFixed(1)} px`;
  sizeVal.textContent    = `${brushSize} px`;
})();
</script>
</body>
</html>
